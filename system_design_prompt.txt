COMBINED SYSTEM DESIGN PROMPT (IS212-G8T4)

Purpose
- Produce consistent changes across the full-stack Task Management System (Next.js frontend + Node/Express backend).
- Respect current architecture, route contracts, role/permission model, and data-flow patterns.
- This prompt is for an AI assistant generating code across both apps.

High-Level Overview
- Domain: Task/project management with role-based access and org hierarchy (team/department/company).
- Frontend: Next.js App Router, TypeScript, Tailwind, context-based auth, typed service layer.
- Backend: Express, domain-driven layering (domain → repositories → services → controllers), JWT auth, role middleware, standardized responses.
- Storage: Local disk attachment storage per task.
- Testing: Frontend Vitest; Backend Jest + supertest (already present).

Key Non-Functional Requirements
- Maintain strict separation of concerns (domain/services/controllers on backend; components/services/hooks/utils on frontend).
- Enforce role-based access (SM/HR > Director > Manager > Staff) consistently.
- Favor idempotent, typed service calls on the frontend; centralized error handling on backend.
- Keep UI responsive; avoid blocking calls in effects; memoize heavy computations.

Architecture (Backend)
- src/domain: Pure business objects (User, Task, Project, Subtask, ActivityLog) with behavior methods.
- src/repositories: Data access; no business logic; CRUD + queries; soft deletes for tasks/subtasks.
- src/services: Business operations; permission checks; orchestration; mapping DTOs; formatting & sorting.
- src/controllers: HTTP request handlers; validate inputs; call services; unify responses via utils.
- src/middleware: auth (JWT), roles/permissions, error handling, attachment processing.
- src/utils: errors, response formatting, async handler.
- src/routes: Organized by domain (auth, users, projects, tasks, subtasks, logs, metrics, notifications, organization).
- src/db: connect, models, seed, schema docs.

Architecture (Frontend)
- src/app: App Router pages (`home`, `login`, `register`, `orgnisation`, `projects-tasks`, `report/department`, `users`).
- src/components: Feature components (tasks, projects, reports, attachments), layout, timeline.
- src/contexts: `UserContext` holding current user and helpers.
- src/lib/services: Typed API clients per backend route grouping (activityLog, auth, metrics, organization, project, subtask, task, user).
- src/lib/hooks: `useTasks`, `useTaskFilters`, `useMetrics`, `useTimeline`, `useUsers`, `useOrgSelectors`.
- src/lib/utils: auth, access/org access, storage, formatDate, timeline math, task sorting/status colors.
- Styling: Tailwind CSS; simple, reusable controls.

Security & Access Control
- JWT validated by backend `authMiddleware.authenticate()`; frontend stores token via `storage` utils (localStorage).
- Role hierarchy (SM/HR: 4, Director: 3, Manager: 2, Staff: 1) drives API access and UI visibility.
- Organization-scoped endpoints: teams (manager+), departments (director+), org-wide (SM/HR).
- Project collaborator roles: viewer/editor (owner assigns) with backward-compatible schema.

Data Models (Essential Fields)
- User: id, name, email, role, teamId, teamName, departmentId, departmentName, resetToken? (backend manages hash/tokens).
- Project: id/_id, name, ownerId, collaborators (legacy ids or subdocs {user, role, assignedBy, assignedAt}), isArchived, timestamps, hasTasks.
- Task: id/_id, title, description, assigneeId, collaborators[], projectIds, priority, status ('unassigned'|'ongoing'|'under_review'|'completed'), dueDate, attachments[], createdAt.
- Subtask: id/_id, parentTaskId, title, status, assigneeId?, createdAt.
- ActivityLog: id, userId, action, resourceType, resourceId, timestamp.
- Department: id, name, teamCount, userCount, directorId?
- Team: id, departmentId, name, userCount, managerId?
- Notification: id, userId, type ('overdue'|'reminder'), message, link, createdAt.

Backend Routes (Contract)
- Auth: POST /api/auth/login, /register, /request-reset, /reset-password
- Users: GET /api/users/profile, /team-members, /department-members/:departmentId?, POST /api/users/invite
- Projects: GET /api/projects/, /departments/:departmentId, GET /:projectId/progress, /:projectId/stats, POST /, PUT /:projectId, PUT /:projectId/archive, PUT /:projectId/collaborators, DELETE /:projectId/collaborators, POST /:projectId/assign-role
- Tasks: GET /api/tasks/ (filters: status, sortBy, order), GET /project/:projectId (status), GET /team/:teamId, GET /department/:departmentId, GET /unassigned, GET /:id, POST /, PUT /:id, PATCH /:id/assign, PATCH /:id/status, PATCH /:id/projects, POST /:id/attachments, DELETE /:id/attachments/:attachmentId, DELETE /:id
- Subtasks: GET /api/tasks/:parentTaskId/subtasks, POST /:parentTaskId/subtasks, GET /subtasks/:id, PUT /subtasks/:id, PATCH /subtasks/:id/status, DELETE /subtasks/:id
- Logs: GET/POST /api/logs/
- Metrics: GET /api/metrics/departments, /teams, /teams/:teamId, /personal
- Organization: GET /api/organization/departments, /departments/:departmentId/teams, /teams
- Notifications: GET/POST /api/notifications

Frontend Service Layer Expectations
- Token automatically attached via config or per-call header.
- Each service maps strict request/response types and returns JSON { status, data, message }.
- Sorting: For due-date sorts, pass sortBy=dueDate + order, otherwise sort client-side by `taskSort.sortTasks`.
- Filtering: Prefer client-side using `useTaskFilters` unless server-side scope (project/team/department) is required.

Key Frontend Flows
1) Authentication
- Login page calls auth.login → stores token → refreshUser via UserContext → route to /home.
- Register via invitation: token in URL → register service → redirect to login on success.
- Reset password: request-reset → link with token → reset-password.

2) Projects & Tasks (Combined Interface)
- Load projects for user; auto-select first project.
- When a project is selected, GET tasks by project; Unassigned view uses GET /tasks/unassigned.
- Task list uses `useTaskFilters` for status/overdue filtering and sort selection; creation modals integrated.

3) Organization Tasks (Department/Team)
- Role-driven selectors loaded via `loadOrgSelectors`.
- Fetch visible tasks by team or department using `getVisibleTasks` (falls back to personal tasks when needed).
- IMPORTANT: Fetch all tasks for KPI accuracy; filter client-side; only send due-date sort to backend.
- Status filter supports: all, unassigned, ongoing, under_review, completed, overdue.

4) Timeline (Home)
- `useTimeline` aggregates items (projects/tasks/subtasks) into a unified timeline.
- Notification reminders: client computes due dates, posts to /notifications for overdue and reminders, and emits 'refreshNotifications' event.

5) Users (HR)
- HR can send bulk invitations; loads departments/teams; validates emails; calls userService.sendBulkInvitations.

Role & Permission Summary (Frontend Expectations)
- Staff: own tasks and tasks where collaborator; limited project collab; no org-wide views.
- Manager: team-wide visibility; can assign within team.
- Director: department-wide visibility; assign within department.
- HR/SM: org-wide visibility; HR cannot modify tasks/projects; SM can assign downward.
- Project roles (viewer/editor) constrain actions within each project.

UI/UX Conventions
- Reuse controls: `TaskStatusFilter`, `TaskSortSelect`, `TaskFilterBar`, `TaskItem`, `SubtaskList`.
- KPI buttons are filters; Overdue is clickable and sets filter='overdue'.
- Avoid mixing server and client filtering for the same dimension; prefer client for status/overdue.

Error Handling
- Backend: Centralized `errorHandler` maps operational errors to status codes; controllers use `asyncHandler`.
- Frontend: Service returns are checked; show toast/message; guard pages with basic loading/error states.

Performance & State
- Memoize computed lists/counts (`useMemo` in `useTaskFilters`, timeline layout computations).
- Keep effects dependency arrays minimal and correct; avoid infinite loops (e.g., don’t depend on state being updated inside effect).

Attachments
- Upload via POST /tasks/:id/attachments (multipart/form-data) with size/type validation (PDF/DOCX/XLSX, 5MB).
- Stored in backend/src/storage/<taskId>/.

Conventions for New Features
- Add backend: domain behavior → repository method → service orchestration → controller → route.
- Add frontend: service function + types → optional hook → UI component → page.
- Maintain typed contracts and role checks; update README coverage if new routes.

Testing Guidance
- Backend: Add integration tests under backend/__tests__/integration/ matching new routes; mock auth as needed.
- Frontend: Add Vitest tests around reusable hooks/components; mock services.

Cross-Cutting Concerns
- IDs may appear as `id` or `_id` in legacy objects; always normalize at boundaries in services/components.
- Project collaborator schema is backward-compatible; handle both array-of-ids and subdoc forms.
- Sorting/Filtering: server handles scope and due-date sort; client handles status/priority + KPIs.

Known Fixed Issues (Keep Correct)
- Root route now redirects token users to `/home`, otherwise `/login`.
- Organization page retrieves full set (no status filter) to avoid KPI mismatch; overdue is a real filter.
- Projects-tasks `useEffect` dependencies corrected to avoid unnecessary re-fetches.
- Home notifications effect excludes `remindersSent` from deps to avoid repeated triggers.

Glossary
- KPI: counts by status plus overdue.
- Visible Tasks: tasks returned given org scope + role constraints.
- Overdue: dueDate < now and status != completed.

END OF PROMPT

